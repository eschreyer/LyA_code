import numpy as np
import scipy.interpolate as sp_intpl
import scipy.optimize as sp_opt
from numba import jit
from tail_object_holders_new import *

"""In this module, we change the coordinates of the tail trajectory, calculated
in the trajectory tail cartesian module, from polar coordinates in the orbital
plane into cartesian coords (x,y,z) in which the positive z direction denotes
the line of sight to earth and the x-y plane contains the observed stellar disk.
The orbital plane is inclined with respect to the x-y plane by i."""


"""
Functions that do coordinate transformations for arbitary points/vectors from
orbital plane to transit coords

Important: Both convert_point_on_orbitalplane_to_transitcoords and convert_vector_on_orbitalplane_to_transitcoords
do this transformation in the inertial frame
------------------------------------------------------------------------------
"""

def convert_point_on_orbitalplane_to_transitcoords(r, theta, i):
    """
    Convert points on the tail from orbital plane to transit coords

    Parameters
    --------------------
    r: The radial coordinate in the orbital plane

    theta: The polar coordinate in the orbital plane.
    We take theta = 0 to be inline with the x-axis in the cartesian coordinate

    i: Inclination of the orbital plane. This is measured anti-clockwise from the
    plane of the sky

    Returns
    --------------------
    Array ([x,y,z])

    """
    x = r*np.cos(theta)
    y = r*np.sin(theta)*np.cos(i)
    z = r*np.sin(theta)*np.sin(i)
    return np.array([x,y,z])



def convert_vector_on_orbitalplane_to_transitcoords(A_r, A_theta, r, theta, i, omega_rot = 0):
    """
    The idea is the same as the above, except we want to convert vectors.

    Parameters
    -----------------------
    A_r: The radial vector in orbital plane

    A_theta: The angular vector in the orbital plane. For velocity, we have
    U_theta = r*theta_dot

    r: The radial coordinate in the orbital plane

    theta: The angular coordinate in the orbital plane

    i: Inclination

    omega_rot: if omega_rot is specified, then do rotating frame transformation
    """
    A_x = A_r * np.cos(theta) - (A_theta + omega_rot * r) * np.sin(theta)
    A_y = A_r * np.sin(theta) * np.cos(i) + (A_theta + omega_rot * r) * np.cos(theta) * np.cos(i)
    A_z = A_r * np.sin(theta) * np.sin(i) + (A_theta + omega_rot * r) * np.cos(theta) * np.sin(i)
    return np.array([A_x, A_y, A_z])


def convert_vector_in_transitcoords_from_rotating_to_inertial(A_x, A_y, A_z, x, y, z, omega_p, i):

    r = np.sqrt(x**2 + y**2 + z**2)
    theta = np.arctan2(np.sqrt(y**2 + z**2), x)
    A_xi = A_x - omega_p * r * np.sin(theta)
    A_yi = A_y + omega_p * r * np.cos(theta) * np.cos(i)
    A_zi = A_z + omega_p * r * np.cos(theta) * np.sin(i)
    return np.array([A_xi, A_yi, A_zi])





"""
Functions that change tail trajectory from

"""

def change_tail_trajectory_from_orbitalplane_to_transitcoords(orbital_plane_solution, theta_offset, i, omega_p = 0):
    """


    Parameters
    ---------------
    orbital_plane_solution: takes a orbital plane tail trajectory solution generated by trajectory_solution_polar
    in trajectory tail cartesian.

    theta_offset: the tail geometry is calculated assuming the planet is at theta = 0. We add an offset theta,
    which is defined to be 0 inline with the postive x-axis (and measured anticlockwise),
    to calculate the transit coordinates of the tail at different points in the orbit of the planet.

    i: inclination

    omega_p: as our orbital plane solution is a rotating reference, we can use this factor to turn into a inertial
    reference frame. If you want inertial, set factor to keplerian velocity. If you want rotating, set to zero
    Set to zero by defualt because we do ray tracing in rotating frame. We only want to change velocities for doppler shift purposes.

    Returns
    ---------------
    A TailTransitCoordArray named tuple object

    """

    tail_position = convert_point_on_orbitalplane_to_transitcoords(orbital_plane_solution.y[1], orbital_plane_solution.y[3] + theta_offset, i)


    tail_velocity = convert_vector_on_orbitalplane_to_transitcoords(orbital_plane_solution.y[0], orbital_plane_solution.y[2] + omega_p * orbital_plane_solution.y[1], orbital_plane_solution.y[1], orbital_plane_solution.y[3] + theta_offset, i)
    #the ray tracing should be done in the inertial frame but the velocities for the doppler shift need to be calculated in the rotating frame

    tail_transitcoords_array = TailTransitCoordArray(s = orbital_plane_solution.t,
                                                   x = tail_position[0],
                                                   y = tail_position[1],
                                                   z = tail_position[2],
                                                   velocity_x = tail_velocity[0],
                                                   velocity_y = tail_velocity[1],
                                                   velocity_z = tail_velocity[2],
                                                   neutral_fraction = orbital_plane_solution.y[4])
    return tail_transitcoords_array



def convert_transitcoords_tail_from_array_to_interpolant(tail_transit_coords_array):
    """
    Interpolates all the tail attributes, so that we evaluate them at any distance, s, down the tail.

    Returns
    ----------------
    A TailTransitCoordinateInterpolate named tuple
    """
    x_function = sp_intpl.InterpolatedUnivariateSpline(tail_transit_coords_array.s, tail_transit_coords_array.x)
    y_function = sp_intpl.InterpolatedUnivariateSpline(tail_transit_coords_array.s, tail_transit_coords_array.y)
    z_function = sp_intpl.InterpolatedUnivariateSpline(tail_transit_coords_array.s, tail_transit_coords_array.z)
    velocity_x_function = sp_intpl.InterpolatedUnivariateSpline(tail_transit_coords_array.s, tail_transit_coords_array.velocity_x)
    velocity_y_function = sp_intpl.InterpolatedUnivariateSpline(tail_transit_coords_array.s, tail_transit_coords_array.velocity_y)
    velocity_z_function = sp_intpl.InterpolatedUnivariateSpline(tail_transit_coords_array.s, tail_transit_coords_array.velocity_z)
    neutral_fraction = sp_intpl.InterpolatedUnivariateSpline(tail_transit_coords_array.s,tail_transit_coords_array.neutral_fraction)

    tail_transitcoord_interpolant = TailTransitCoordInterpolate(x = x_function,
                                                                 y = y_function,
                                                                 z = z_function,
                                                                 velocity_x = velocity_x_function,
                                                                 velocity_y = velocity_y_function,
                                                                 velocity_z = velocity_z_function,
                                                                 neutral_fraction = neutral_fraction)

    return tail_transitcoord_interpolant
